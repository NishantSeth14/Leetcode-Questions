//Sort it using diff vector
//Method 1

class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        vector<int> diff;
        for(int i=0; i<arr.size(); i++){
            diff.push_back(abs(x - arr[i]));
        }

        // Creating a custom comparison function for sorting
        auto compare = [&](int a, int b) {
            if (diff[a] == diff[b]) {
                return arr[a] < arr[b];
            }
            return diff[a] < diff[b];
        };

        // Create an index vector and sort it based on the custom comparison function
        vector<int> indices(arr.size());
        for (int i = 0; i < arr.size(); i++) {
            indices[i] = i;
        }
        sort(indices.begin(), indices.end(), compare);

        // Create a result vector containing the first k elements from the sorted indices
        vector<int> result;
        for (int i = 0; i < k; i++) {
            result.push_back(arr[indices[i]]);
        }

        // Sort the result vector in ascending order (optional)
        sort(result.begin(), result.end());

        return result;
    }
};

//Method 2 Using Two Pointer
//T.C O(n-k)
//S.C O(k)

class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        int  l = 0;
        int h = arr.size()-1;

        while(h - l >= k){
            if(x - arr[l] > arr[h] - x){
                l++;
            }
            else{
                h--;
            }
        }
        vector<int> ans;
        for(int i=l ; i <= h; i++){
            ans.push_back(arr[i]);
        }
        return ans;
        //return vector<int>(arr.begin()+l, arr.begin()+h+1);
    }
};

//Method 3 Using Binary Search

